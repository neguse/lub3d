#!/usr/bin/env python3
"""
Generate pack data as C source from lib/*.lua, deps/lume/lume.lua,
examples/**/*.lua, and example assets.
"""
import os
import glob
import argparse


def collect_files(root):
    """Collect all files to pack."""
    entries = []

    # lib/*.lua
    for path in sorted(glob.glob(os.path.join(root, "lib", "*.lua"))):
        rel = os.path.relpath(path, root).replace("\\", "/")
        entries.append(rel)

    # deps/lume/lume.lua
    lume = os.path.join(root, "deps", "lume", "lume.lua")
    if os.path.exists(lume):
        entries.append("deps/lume/lume.lua")

    # examples/**/*.lua
    for path in sorted(glob.glob(os.path.join(root, "examples", "**", "*.lua"), recursive=True)):
        rel = os.path.relpath(path, root).replace("\\", "/")
        # skip examples/main.c companion files if any
        entries.append(rel)

    # examples/**/assets/** (binary assets)
    for path in sorted(glob.glob(os.path.join(root, "examples", "**", "assets", "**"), recursive=True)):
        if os.path.isfile(path):
            rel = os.path.relpath(path, root).replace("\\", "/")
            if rel not in entries:
                entries.append(rel)

    # examples/**/test/fixtures/** (test fixture files)
    for path in sorted(glob.glob(os.path.join(root, "examples", "**", "test", "fixtures", "**"), recursive=True)):
        if os.path.isfile(path):
            rel = os.path.relpath(path, root).replace("\\", "/")
            if rel not in entries:
                entries.append(rel)

    return entries


def generate_c_source(root, entries, output_path):
    """Generate C source file with embedded pack data."""
    lines = [
        "/* Auto-generated by gen_pack.py - do not edit */",
        "",
    ]

    # Emit each file as a byte array
    for i, rel in enumerate(entries):
        filepath = os.path.join(root, rel)
        with open(filepath, "rb") as f:
            data = f.read()

        lines.append(f"/* {rel} ({len(data)} bytes) */")
        if len(data) == 0:
            lines.append(f"static const unsigned char pack_data_{i}[] = {{ 0 }};")
        else:
            # Emit as hex bytes, 16 per line
            hex_lines = []
            for off in range(0, len(data), 16):
                chunk = data[off:off + 16]
                hex_lines.append("    " + ", ".join(f"0x{b:02x}" for b in chunk))
            lines.append(f"static const unsigned char pack_data_{i}[] = {{")
            lines.append(",\n".join(hex_lines))
            lines.append("};")
        lines.append("")

    # Emit the lookup table (lub3d_pack_entry_t is defined in lub3d_pack.h)
    lines.append("typedef struct {")
    lines.append("    const char *path;")
    lines.append("    const unsigned char *data;")
    lines.append("    unsigned int size;")
    lines.append("} lub3d_pack_entry_t;")
    lines.append("")
    lines.append(f"const lub3d_pack_entry_t lub3d_pack_entries[] = {{")
    for i, rel in enumerate(entries):
        filepath = os.path.join(root, rel)
        size = os.path.getsize(filepath)
        lines.append(f'    {{"{rel}", pack_data_{i}, {size}}},')
    lines.append("};")
    lines.append("")
    lines.append(f"const int lub3d_pack_count = {len(entries)};")
    lines.append("")

    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))
        f.write("\n")


def main():
    parser = argparse.ArgumentParser(description="Generate pack data")
    script_dir = os.path.dirname(__file__)
    parser.add_argument("--root", default=os.path.abspath(os.path.join(script_dir, "..")),
                        help="Root directory")
    parser.add_argument("--output", default=None, help="Output C file")
    args = parser.parse_args()

    root = os.path.abspath(args.root)
    output = args.output or os.path.join(root, "gen", "pack.c")

    print(f"Scanning {root} for pack files...")
    entries = collect_files(root)

    print(f"Found {len(entries)} files:")
    total_size = 0
    for rel in entries:
        size = os.path.getsize(os.path.join(root, rel))
        total_size += size
        print(f"  {rel} ({size} bytes)")
    print(f"Total: {total_size} bytes")

    print(f"Generating {output}...")
    generate_c_source(root, entries, output)
    print("Done.")


if __name__ == "__main__":
    main()
