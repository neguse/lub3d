// Box2D v3 — physics engine bindings
[Prefix="b2", CInclude="box2d/box2d.h,box2d/math_functions.h,box2d/collision.h",
FuncNaming="PascalCase",
ExtraCCode="extra/box2d_extra.c",
ExtraLuaReg="manifold_point_count:l_b2d_manifold_point_count,manifold_point:l_b2d_manifold_point,manifold_normal:l_b2d_manifold_normal,world_set_friction_callback:l_b2d_world_set_friction_callback,world_set_restitution_callback:l_b2d_world_set_restitution_callback,world_collide_mover:l_b2d_world_collide_mover,clip_vector:l_b2d_clip_vector,solve_planes:l_b2d_solve_planes",
ExtraLuaFunc="manifold_point_count:VoidPtr:long,manifold_point:VoidPtr+long:b2Vec2,manifold_normal:VoidPtr:b2Vec2,world_set_friction_callback:b2WorldId+Callback?:void,world_set_restitution_callback:b2WorldId+Callback?:void,world_collide_mover:b2WorldId+b2Capsule+b2QueryFilter+Callback:void,clip_vector:b2Vec2+b2CollisionPlane:b2Vec2,solve_planes:b2Vec2+b2CollisionPlane:b2PlaneSolverResult"]

// ===== ValueStruct types =====

[ValueStruct]
dictionary b2Vec2 {
    float x;
    float y;
};

[ValueStruct, ReadOnly]
dictionary b2CosSin {
    float cosine;
    float sine;
};

[ValueStruct]
dictionary b2Rot {
    float c;
    float s;
};

[ValueStruct, ReadOnly, Nested="p:x+y,q:c+s"]
dictionary b2Transform {};

[ValueStruct, ReadOnly, Nested="lowerBound:x+y,upperBound:x+y"]
dictionary b2AABB {};

[ValueStruct, Nested="normal:x+y"]
dictionary b2Plane {
    float offset;
};

// ===== Callback types =====

callback b2OverlapResultFcn = boolean (b2ShapeId shapeId);

callback b2CastResultFcn = float (b2ShapeId shapeId, b2Vec2 point, b2Vec2 normal, float fraction);

[Persistent]
callback b2PreSolveFcn = boolean (b2ShapeId shapeIdA, b2ShapeId shapeIdB, VoidPtr manifold);

[Persistent]
callback b2CustomFilterFcn = boolean (b2ShapeId shapeIdA, b2ShapeId shapeIdB);

callback b2PlaneResultFcn = boolean (b2ShapeId shapeId, b2PlaneResult planeResult);

// ===== Handle types =====

[HandleType]
dictionary b2WorldId {
    unsigned short index1;
    unsigned short revision;
};

[HandleType]
dictionary b2BodyId {
    unsigned short index1;
    unsigned short revision;
};

[HandleType]
dictionary b2ShapeId {
    unsigned short index1;
    unsigned short revision;
};

[HandleType]
dictionary b2JointId {
    unsigned short index1;
    unsigned short revision;
};

[HandleType]
dictionary b2ChainId {
    unsigned short index1;
    unsigned short revision;
};

// ===== Enums =====

[EnumItemStyle="CamelCase"]
enum b2BodyType {
    "b2_staticBody" = 0,
    "b2_kinematicBody" = 1,
    "b2_dynamicBody" = 2,
};

[EnumItemStyle="CamelCase"]
enum b2ShapeType {
    "b2_circleShape" = 0,
    "b2_capsuleShape" = 1,
    "b2_segmentShape" = 2,
    "b2_polygonShape" = 3,
    "b2_chainSegmentShape" = 4,
};

[EnumItemStyle="CamelCase"]
enum b2JointType {
    "b2_distanceJoint" = 0,
    "b2_filterJoint" = 1,
    "b2_motorJoint" = 2,
    "b2_mouseJoint" = 3,
    "b2_prismaticJoint" = 4,
    "b2_revoluteJoint" = 5,
    "b2_weldJoint" = 6,
    "b2_wheelJoint" = 7,
};

[EnumItemStyle="CamelCase"]
enum b2TOIState {
    "b2_toiStateUnknown" = 0,
    "b2_toiStateFailed" = 1,
    "b2_toiStateOverlapped" = 2,
    "b2_toiStateHit" = 3,
    "b2_toiStateSeparated" = 4,
};

// ===== Def structs (HasMetamethods = true) =====

[CamelCase, HasMetamethods]
dictionary b2WorldDef {
    [Ignore] Callback enqueueTask;
    [Ignore] Callback finishTask;
    [Ignore] VoidPtr userTaskContext;
    [Ignore] VoidPtr userData;
    [Ignore] Callback frictionCallback;
    [Ignore] Callback restitutionCallback;
    b2Vec2 gravity;
    float restitutionThreshold;
    float hitEventThreshold;
    float contactHertz;
    float contactDampingRatio;
    float maxContactPushSpeed;
    float maximumLinearSpeed;
    boolean enableSleep;
    boolean enableContinuous;
    long workerCount;
    long internalValue;
};

[CamelCase, HasMetamethods]
dictionary b2BodyDef {
    [Ignore] VoidPtr userData;
    b2BodyType type;
    b2Vec2 position;
    b2Rot rotation;
    b2Vec2 linearVelocity;
    float angularVelocity;
    float linearDamping;
    float angularDamping;
    float gravityScale;
    float sleepThreshold;
    DOMString name;
    boolean enableSleep;
    boolean isAwake;
    boolean fixedRotation;
    boolean isBullet;
    boolean isEnabled;
    boolean allowFastRotation;
    long internalValue;
};

[CamelCase, HasMetamethods]
dictionary b2ShapeDef {
    [Ignore] VoidPtr userData;
    b2SurfaceMaterial material;
    float density;
    b2Filter filter;
    boolean isSensor;
    boolean enableSensorEvents;
    boolean enableContactEvents;
    boolean enableHitEvents;
    boolean enablePreSolveEvents;
    boolean invokeContactCreation;
    boolean updateBodyMass;
    long internalValue;
};

[CamelCase, HasMetamethods, Property_points="extra/b2_chain_points.c:b2Vec2", Property_materials="extra/b2_chain_materials.c:b2SurfaceMaterial"]
dictionary b2ChainDef {
    [Ignore] VoidPtr userData;
    [Ignore] VoidPtr points;
    [Ignore] long count;
    [Ignore] VoidPtr materials;
    [Ignore] long materialCount;
    b2Filter filter;
    boolean isLoop;
    boolean enableSensorEvents;
    long internalValue;
};

[CamelCase, HasMetamethods]
dictionary b2DistanceJointDef {
    [Ignore] VoidPtr userData;
    b2BodyId bodyIdA;
    b2BodyId bodyIdB;
    b2Vec2 localAnchorA;
    b2Vec2 localAnchorB;
    float length;
    boolean enableSpring;
    float hertz;
    float dampingRatio;
    boolean enableLimit;
    float minLength;
    float maxLength;
    boolean enableMotor;
    float maxMotorForce;
    float motorSpeed;
    boolean collideConnected;
    long internalValue;
};

[CamelCase, HasMetamethods]
dictionary b2MotorJointDef {
    [Ignore] VoidPtr userData;
    b2BodyId bodyIdA;
    b2BodyId bodyIdB;
    b2Vec2 linearOffset;
    float angularOffset;
    float maxForce;
    float maxTorque;
    float correctionFactor;
    boolean collideConnected;
    long internalValue;
};

[CamelCase, HasMetamethods]
dictionary b2MouseJointDef {
    [Ignore] VoidPtr userData;
    b2BodyId bodyIdA;
    b2BodyId bodyIdB;
    b2Vec2 target;
    float hertz;
    float dampingRatio;
    float maxForce;
    boolean collideConnected;
    long internalValue;
};

[CamelCase, HasMetamethods]
dictionary b2FilterJointDef {
    [Ignore] VoidPtr userData;
    b2BodyId bodyIdA;
    b2BodyId bodyIdB;
    long internalValue;
};

[CamelCase, HasMetamethods]
dictionary b2PrismaticJointDef {
    [Ignore] VoidPtr userData;
    b2BodyId bodyIdA;
    b2BodyId bodyIdB;
    b2Vec2 localAnchorA;
    b2Vec2 localAnchorB;
    b2Vec2 localAxisA;
    float referenceAngle;
    float targetTranslation;
    boolean enableSpring;
    float hertz;
    float dampingRatio;
    boolean enableLimit;
    float lowerTranslation;
    float upperTranslation;
    boolean enableMotor;
    float maxMotorForce;
    float motorSpeed;
    boolean collideConnected;
    long internalValue;
};

[CamelCase, HasMetamethods]
dictionary b2RevoluteJointDef {
    [Ignore] VoidPtr userData;
    b2BodyId bodyIdA;
    b2BodyId bodyIdB;
    b2Vec2 localAnchorA;
    b2Vec2 localAnchorB;
    float referenceAngle;
    float targetAngle;
    boolean enableSpring;
    float hertz;
    float dampingRatio;
    boolean enableLimit;
    float lowerAngle;
    float upperAngle;
    boolean enableMotor;
    float maxMotorTorque;
    float motorSpeed;
    float drawSize;
    boolean collideConnected;
    long internalValue;
};

[CamelCase, HasMetamethods]
dictionary b2WeldJointDef {
    [Ignore] VoidPtr userData;
    b2BodyId bodyIdA;
    b2BodyId bodyIdB;
    b2Vec2 localAnchorA;
    b2Vec2 localAnchorB;
    float referenceAngle;
    float linearHertz;
    float angularHertz;
    float linearDampingRatio;
    float angularDampingRatio;
    boolean collideConnected;
    long internalValue;
};

[CamelCase, HasMetamethods]
dictionary b2WheelJointDef {
    [Ignore] VoidPtr userData;
    b2BodyId bodyIdA;
    b2BodyId bodyIdB;
    b2Vec2 localAnchorA;
    b2Vec2 localAnchorB;
    b2Vec2 localAxisA;
    boolean enableSpring;
    float hertz;
    float dampingRatio;
    boolean enableLimit;
    float lowerTranslation;
    float upperTranslation;
    boolean enableMotor;
    float maxMotorTorque;
    float motorSpeed;
    boolean collideConnected;
    long internalValue;
};

[CamelCase, HasMetamethods]
dictionary b2Filter {
    unsigned long long categoryBits;
    unsigned long long maskBits;
    long groupIndex;
};

[CamelCase, HasMetamethods]
dictionary b2QueryFilter {
    unsigned long long categoryBits;
    unsigned long long maskBits;
};

[CamelCase, HasMetamethods]
dictionary b2SurfaceMaterial {
    float friction;
    float restitution;
    float rollingResistance;
    float tangentSpeed;
    long userMaterialId;
    unsigned long customColor;
};

[CamelCase, HasMetamethods]
dictionary b2ExplosionDef {
    unsigned long long maskBits;
    b2Vec2 position;
    float radius;
    float falloff;
    float impulsePerLength;
};

// ===== Geometry structs (HasMetamethods = true) =====

[CamelCase, HasMetamethods]
dictionary b2Circle {
    b2Vec2 center;
    float radius;
};

[CamelCase, HasMetamethods]
dictionary b2Capsule {
    b2Vec2 center1;
    b2Vec2 center2;
    float radius;
};

[CamelCase, HasMetamethods]
dictionary b2Segment {
    b2Vec2 point1;
    b2Vec2 point2;
};

[CamelCase, HasMetamethods]
dictionary b2Polygon {
    b2Vec2 vertices[8];
    b2Vec2 normals[8];
    b2Vec2 centroid;
    float radius;
    long count;
};

[CamelCase, HasMetamethods]
dictionary b2ChainSegment {
    b2Vec2 ghost1;
    b2Segment segment;
    b2Vec2 ghost2;
    long chainId;
};

[CamelCase, HasMetamethods]
dictionary b2Hull {
    b2Vec2 points[8];
    long count;
};

[CamelCase, HasMetamethods]
dictionary b2MassData {
    float mass;
    b2Vec2 center;
    float rotationalInertia;
};

[CamelCase, HasMetamethods]
dictionary b2RayCastInput {
    b2Vec2 origin;
    b2Vec2 translation;
    float maxFraction;
};

[CamelCase, HasMetamethods]
dictionary b2ShapeProxy {
    b2Vec2 points[8];
    long count;
    float radius;
};

[CamelCase, HasMetamethods]
dictionary b2ShapeCastInput {
    b2ShapeProxy proxy;
    b2Vec2 translation;
    float maxFraction;
    boolean canEncroach;
};

[CamelCase, HasMetamethods]
dictionary b2CastOutput {
    b2Vec2 normal;
    b2Vec2 point;
    float fraction;
    long iterations;
    boolean hit;
};

[CamelCase, HasMetamethods]
dictionary b2RayResult {
    b2ShapeId shapeId;
    b2Vec2 point;
    b2Vec2 normal;
    float fraction;
    long nodeVisits;
    long leafVisits;
    boolean hit;
};

[CamelCase, HasMetamethods]
dictionary b2Version {
    long major;
    long minor;
    long revision;
};

[CamelCase, HasMetamethods]
dictionary b2Profile {
    float step;
    float pairs;
    float collide;
    float solve;
    float mergeIslands;
    float prepareStages;
    float solveConstraints;
    float prepareConstraints;
    float integrateVelocities;
    float warmStart;
    float solveImpulses;
    float integratePositions;
    float relaxImpulses;
    float applyRestitution;
    float storeImpulses;
    float splitIslands;
    float transforms;
    float hitEvents;
    float refit;
    float bullets;
    float sleepIslands;
    float sensors;
};

[CamelCase, HasMetamethods]
dictionary b2Counters {
    long bodyCount;
    long shapeCount;
    long contactCount;
    long jointCount;
    long islandCount;
    long stackUsed;
    long staticTreeHeight;
    long treeHeight;
    long byteCount;
    long taskCount;
    long colorCounts[12];
};

[CamelCase, HasMetamethods]
dictionary b2Sweep {
    b2Vec2 localCenter;
    b2Vec2 c1;
    b2Vec2 c2;
    b2Rot q1;
    b2Rot q2;
};

[CamelCase, HasMetamethods]
dictionary b2TOIInput {
    b2ShapeProxy proxyA;
    b2ShapeProxy proxyB;
    b2Sweep sweepA;
    b2Sweep sweepB;
    float maxFraction;
};

[CamelCase, HasMetamethods]
dictionary b2TOIOutput {
    b2TOIState state;
    float fraction;
};

[CamelCase, HasMetamethods]
dictionary b2PlaneResult {
    b2Plane plane;
    b2Vec2 point;
    boolean hit;
};

[CamelCase, HasMetamethods]
dictionary b2CollisionPlane {
    b2Plane plane;
    float pushLimit;
    float push;
    boolean clipVelocity;
};

[CamelCase, HasMetamethods]
dictionary b2PlaneSolverResult {
    b2Vec2 translation;
    long iterationCount;
};

// ===== Namespace functions =====

namespace b2d {

    // --- Default Defs ---
    [PostCallPatch="enqueueTask:(b2EnqueueTaskCallback*)b2d_enqueue_task,finishTask:b2d_finish_task"]
    b2WorldDef DefaultWorldDef();
    b2BodyDef DefaultBodyDef();
    b2ShapeDef DefaultShapeDef();
    b2ChainDef DefaultChainDef();
    b2Filter DefaultFilter();
    b2QueryFilter DefaultQueryFilter();
    b2SurfaceMaterial DefaultSurfaceMaterial();
    b2ExplosionDef DefaultExplosionDef();
    b2DistanceJointDef DefaultDistanceJointDef();
    b2MotorJointDef DefaultMotorJointDef();
    b2MouseJointDef DefaultMouseJointDef();
    b2FilterJointDef DefaultFilterJointDef();
    b2PrismaticJointDef DefaultPrismaticJointDef();
    b2RevoluteJointDef DefaultRevoluteJointDef();
    b2WeldJointDef DefaultWeldJointDef();
    b2WheelJointDef DefaultWheelJointDef();

    // --- World ---
    b2WorldId CreateWorld(b2WorldDef def);
    void DestroyWorld(b2WorldId worldId);
    boolean World_IsValid(b2WorldId id);
    void World_Step(b2WorldId worldId, float timeStep, long subStepCount);
    void World_OverlapAABB(b2WorldId worldId, b2AABB aabb, b2QueryFilter filter, b2OverlapResultFcn fcn, VoidPtr context);
    void World_OverlapShape(b2WorldId worldId, b2ShapeProxy proxy, b2QueryFilter filter, b2OverlapResultFcn fcn, VoidPtr context);
    void World_CastRay(b2WorldId worldId, b2Vec2 origin, b2Vec2 translation, b2QueryFilter filter, b2CastResultFcn fcn, VoidPtr context);
    b2RayResult World_CastRayClosest(b2WorldId worldId, b2Vec2 origin, b2Vec2 translation, b2QueryFilter filter);
    void World_CastShape(b2WorldId worldId, b2ShapeProxy proxy, b2Vec2 translation, b2QueryFilter filter, b2CastResultFcn fcn, VoidPtr context);
    float World_CastMover(b2WorldId worldId, b2Capsule mover, b2Vec2 translation, b2QueryFilter filter);
    void World_EnableSleeping(b2WorldId worldId, boolean flag);
    boolean World_IsSleepingEnabled(b2WorldId worldId);
    void World_EnableContinuous(b2WorldId worldId, boolean flag);
    boolean World_IsContinuousEnabled(b2WorldId worldId);
    void World_SetRestitutionThreshold(b2WorldId worldId, float value);
    float World_GetRestitutionThreshold(b2WorldId worldId);
    void World_SetHitEventThreshold(b2WorldId worldId, float value);
    float World_GetHitEventThreshold(b2WorldId worldId);
    void World_SetCustomFilterCallback(b2WorldId worldId, b2CustomFilterFcn fcn, VoidPtr context);
    void World_SetPreSolveCallback(b2WorldId worldId, b2PreSolveFcn fcn, VoidPtr context);
    void World_SetGravity(b2WorldId worldId, b2Vec2 gravity);
    b2Vec2 World_GetGravity(b2WorldId worldId);
    void World_Explode(b2WorldId worldId, b2ExplosionDef explosionDef);
    void World_SetContactTuning(b2WorldId worldId, float hertz, float dampingRatio, float pushSpeed);
    void World_SetMaximumLinearSpeed(b2WorldId worldId, float maximumLinearSpeed);
    float World_GetMaximumLinearSpeed(b2WorldId worldId);
    void World_EnableWarmStarting(b2WorldId worldId, boolean flag);
    boolean World_IsWarmStartingEnabled(b2WorldId worldId);
    long World_GetAwakeBodyCount(b2WorldId worldId);
    b2Profile World_GetProfile(b2WorldId worldId);
    b2Counters World_GetCounters(b2WorldId worldId);
    void World_RebuildStaticTree(b2WorldId worldId);

    // --- Body ---
    b2BodyId CreateBody(b2WorldId worldId, b2BodyDef def);
    void DestroyBody(b2BodyId bodyId);
    boolean Body_IsValid(b2BodyId id);
    b2BodyType Body_GetType(b2BodyId bodyId);
    void Body_SetType(b2BodyId bodyId, b2BodyType type);
    void Body_SetName(b2BodyId bodyId, DOMString name);
    DOMString Body_GetName(b2BodyId bodyId);
    b2Vec2 Body_GetPosition(b2BodyId bodyId);
    b2Rot Body_GetRotation(b2BodyId bodyId);
    b2Transform Body_GetTransform(b2BodyId bodyId);
    void Body_SetTransform(b2BodyId bodyId, b2Vec2 position, b2Rot rotation);
    void Body_SetTargetTransform(b2BodyId bodyId, b2Transform target, float timeStep);
    b2Vec2 Body_GetLocalPoint(b2BodyId bodyId, b2Vec2 worldPoint);
    b2Vec2 Body_GetWorldPoint(b2BodyId bodyId, b2Vec2 localPoint);
    b2Vec2 Body_GetLocalVector(b2BodyId bodyId, b2Vec2 worldVector);
    b2Vec2 Body_GetWorldVector(b2BodyId bodyId, b2Vec2 localVector);
    b2Vec2 Body_GetLinearVelocity(b2BodyId bodyId);
    float Body_GetAngularVelocity(b2BodyId bodyId);
    void Body_SetLinearVelocity(b2BodyId bodyId, b2Vec2 linearVelocity);
    void Body_SetAngularVelocity(b2BodyId bodyId, float angularVelocity);
    b2Vec2 Body_GetLocalPointVelocity(b2BodyId bodyId, b2Vec2 localPoint);
    b2Vec2 Body_GetWorldPointVelocity(b2BodyId bodyId, b2Vec2 worldPoint);
    void Body_ApplyForce(b2BodyId bodyId, b2Vec2 force, b2Vec2 point, boolean wake);
    void Body_ApplyForceToCenter(b2BodyId bodyId, b2Vec2 force, boolean wake);
    void Body_ApplyTorque(b2BodyId bodyId, float torque, boolean wake);
    void Body_ApplyLinearImpulse(b2BodyId bodyId, b2Vec2 impulse, b2Vec2 point, boolean wake);
    void Body_ApplyLinearImpulseToCenter(b2BodyId bodyId, b2Vec2 impulse, boolean wake);
    void Body_ApplyAngularImpulse(b2BodyId bodyId, float impulse, boolean wake);
    float Body_GetMass(b2BodyId bodyId);
    float Body_GetRotationalInertia(b2BodyId bodyId);
    b2Vec2 Body_GetLocalCenterOfMass(b2BodyId bodyId);
    b2Vec2 Body_GetWorldCenterOfMass(b2BodyId bodyId);
    void Body_SetMassData(b2BodyId bodyId, b2MassData massData);
    b2MassData Body_GetMassData(b2BodyId bodyId);
    void Body_ApplyMassFromShapes(b2BodyId bodyId);
    void Body_SetLinearDamping(b2BodyId bodyId, float linearDamping);
    float Body_GetLinearDamping(b2BodyId bodyId);
    void Body_SetAngularDamping(b2BodyId bodyId, float angularDamping);
    float Body_GetAngularDamping(b2BodyId bodyId);
    void Body_SetGravityScale(b2BodyId bodyId, float gravityScale);
    float Body_GetGravityScale(b2BodyId bodyId);
    boolean Body_IsAwake(b2BodyId bodyId);
    void Body_SetAwake(b2BodyId bodyId, boolean awake);
    void Body_EnableSleep(b2BodyId bodyId, boolean enableSleep);
    boolean Body_IsSleepEnabled(b2BodyId bodyId);
    void Body_SetSleepThreshold(b2BodyId bodyId, float sleepThreshold);
    float Body_GetSleepThreshold(b2BodyId bodyId);
    boolean Body_IsEnabled(b2BodyId bodyId);
    void Body_Disable(b2BodyId bodyId);
    void Body_Enable(b2BodyId bodyId);
    void Body_SetFixedRotation(b2BodyId bodyId, boolean flag);
    boolean Body_IsFixedRotation(b2BodyId bodyId);
    void Body_SetBullet(b2BodyId bodyId, boolean flag);
    boolean Body_IsBullet(b2BodyId bodyId);
    void Body_EnableContactEvents(b2BodyId bodyId, boolean flag);
    void Body_EnableHitEvents(b2BodyId bodyId, boolean flag);
    long Body_GetContactCapacity(b2BodyId bodyId);
    long Body_GetShapeCount(b2BodyId bodyId);
    long Body_GetJointCount(b2BodyId bodyId);
    b2AABB Body_ComputeAABB(b2BodyId bodyId);
    b2WorldId Body_GetWorld(b2BodyId bodyId);

    // --- Shape ---
    b2ShapeId CreateCircleShape(b2BodyId bodyId, b2ShapeDef def, b2Circle circle);
    b2ShapeId CreateCapsuleShape(b2BodyId bodyId, b2ShapeDef def, b2Capsule capsule);
    b2ShapeId CreatePolygonShape(b2BodyId bodyId, b2ShapeDef def, b2Polygon polygon);
    b2ShapeId CreateSegmentShape(b2BodyId bodyId, b2ShapeDef def, b2Segment segment);
    void DestroyShape(b2ShapeId shapeId, boolean updateBodyMass);
    boolean Shape_IsValid(b2ShapeId id);
    b2ShapeType Shape_GetType(b2ShapeId shapeId);
    b2Circle Shape_GetCircle(b2ShapeId shapeId);
    b2Capsule Shape_GetCapsule(b2ShapeId shapeId);
    b2Polygon Shape_GetPolygon(b2ShapeId shapeId);
    b2Segment Shape_GetSegment(b2ShapeId shapeId);
    b2ChainSegment Shape_GetChainSegment(b2ShapeId shapeId);
    boolean Shape_IsSensor(b2ShapeId shapeId);
    b2Filter Shape_GetFilter(b2ShapeId shapeId);
    void Shape_SetFilter(b2ShapeId shapeId, b2Filter filter);
    b2SurfaceMaterial Shape_GetSurfaceMaterial(b2ShapeId shapeId);
    void Shape_SetSurfaceMaterial(b2ShapeId shapeId, b2SurfaceMaterial surfaceMaterial);
    long Shape_GetMaterial(b2ShapeId shapeId);
    void Shape_SetMaterial(b2ShapeId shapeId, long material);
    float Shape_GetDensity(b2ShapeId shapeId);
    void Shape_SetDensity(b2ShapeId shapeId, float density, boolean updateBodyMass);
    float Shape_GetFriction(b2ShapeId shapeId);
    void Shape_SetFriction(b2ShapeId shapeId, float friction);
    float Shape_GetRestitution(b2ShapeId shapeId);
    void Shape_SetRestitution(b2ShapeId shapeId, float restitution);
    void Shape_SetCircle(b2ShapeId shapeId, b2Circle circle);
    void Shape_SetCapsule(b2ShapeId shapeId, b2Capsule capsule);
    void Shape_SetPolygon(b2ShapeId shapeId, b2Polygon polygon);
    void Shape_SetSegment(b2ShapeId shapeId, b2Segment segment);
    b2AABB Shape_GetAABB(b2ShapeId shapeId);
    b2MassData Shape_GetMassData(b2ShapeId shapeId);
    boolean Shape_TestPoint(b2ShapeId shapeId, b2Vec2 point);
    b2CastOutput Shape_RayCast(b2ShapeId shapeId, b2RayCastInput input);
    b2Vec2 Shape_GetClosestPoint(b2ShapeId shapeId, b2Vec2 target);
    void Shape_EnableContactEvents(b2ShapeId shapeId, boolean flag);
    boolean Shape_AreContactEventsEnabled(b2ShapeId shapeId);
    void Shape_EnableSensorEvents(b2ShapeId shapeId, boolean flag);
    boolean Shape_AreSensorEventsEnabled(b2ShapeId shapeId);
    void Shape_EnableHitEvents(b2ShapeId shapeId, boolean flag);
    boolean Shape_AreHitEventsEnabled(b2ShapeId shapeId);
    void Shape_EnablePreSolveEvents(b2ShapeId shapeId, boolean flag);
    boolean Shape_ArePreSolveEventsEnabled(b2ShapeId shapeId);
    long Shape_GetContactCapacity(b2ShapeId shapeId);
    long Shape_GetSensorCapacity(b2ShapeId shapeId);
    b2BodyId Shape_GetBody(b2ShapeId shapeId);
    b2ChainId Shape_GetParentChain(b2ShapeId shapeId);
    b2WorldId Shape_GetWorld(b2ShapeId shapeId);

    // --- Chain ---
    b2ChainId CreateChain(b2BodyId bodyId, b2ChainDef def);
    void DestroyChain(b2ChainId chainId);
    boolean Chain_IsValid(b2ChainId id);
    long Chain_GetSegmentCount(b2ChainId chainId);
    float Chain_GetFriction(b2ChainId chainId);
    void Chain_SetFriction(b2ChainId chainId, float friction);
    float Chain_GetRestitution(b2ChainId chainId);
    void Chain_SetRestitution(b2ChainId chainId, float restitution);
    long Chain_GetMaterial(b2ChainId chainId);
    void Chain_SetMaterial(b2ChainId chainId, long material);
    b2WorldId Chain_GetWorld(b2ChainId chainId);

    // --- Joint (common) ---
    b2JointId CreateDistanceJoint(b2WorldId worldId, b2DistanceJointDef def);
    b2JointId CreateRevoluteJoint(b2WorldId worldId, b2RevoluteJointDef def);
    b2JointId CreatePrismaticJoint(b2WorldId worldId, b2PrismaticJointDef def);
    b2JointId CreateWheelJoint(b2WorldId worldId, b2WheelJointDef def);
    b2JointId CreateWeldJoint(b2WorldId worldId, b2WeldJointDef def);
    b2JointId CreateMouseJoint(b2WorldId worldId, b2MouseJointDef def);
    b2JointId CreateMotorJoint(b2WorldId worldId, b2MotorJointDef def);
    b2JointId CreateFilterJoint(b2WorldId worldId, b2FilterJointDef def);
    void DestroyJoint(b2JointId jointId);
    boolean Joint_IsValid(b2JointId id);
    b2JointType Joint_GetType(b2JointId jointId);
    b2BodyId Joint_GetBodyA(b2JointId jointId);
    b2BodyId Joint_GetBodyB(b2JointId jointId);
    b2Vec2 Joint_GetLocalAnchorA(b2JointId jointId);
    b2Vec2 Joint_GetLocalAnchorB(b2JointId jointId);
    b2Vec2 Joint_GetLocalAxisA(b2JointId jointId);
    float Joint_GetReferenceAngle(b2JointId jointId);
    boolean Joint_GetCollideConnected(b2JointId jointId);
    void Joint_SetCollideConnected(b2JointId jointId, boolean shouldCollide);
    float Joint_GetLinearSeparation(b2JointId jointId);
    float Joint_GetAngularSeparation(b2JointId jointId);
    b2Vec2 Joint_GetConstraintForce(b2JointId jointId);
    float Joint_GetConstraintTorque(b2JointId jointId);
    void Joint_SetConstraintTuning(b2JointId jointId, float hertz, float dampingRatio);
    void Joint_SetLocalAnchorA(b2JointId jointId, b2Vec2 localAnchor);
    void Joint_SetLocalAnchorB(b2JointId jointId, b2Vec2 localAnchor);
    void Joint_SetLocalAxisA(b2JointId jointId, b2Vec2 localAxis);
    void Joint_SetReferenceAngle(b2JointId jointId, float angleInRadians);
    void Joint_WakeBodies(b2JointId jointId);
    b2WorldId Joint_GetWorld(b2JointId jointId);
    [OutputParams="hertz,dampingRatio"]
    void Joint_GetConstraintTuning(b2JointId jointId, float hertz, float dampingRatio);

    // --- Distance Joint ---
    boolean DistanceJoint_IsSpringEnabled(b2JointId jointId);
    void DistanceJoint_EnableSpring(b2JointId jointId, boolean enableSpring);
    float DistanceJoint_GetSpringHertz(b2JointId jointId);
    void DistanceJoint_SetSpringHertz(b2JointId jointId, float hertz);
    float DistanceJoint_GetSpringDampingRatio(b2JointId jointId);
    void DistanceJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);
    float DistanceJoint_GetMinLength(b2JointId jointId);
    float DistanceJoint_GetMaxLength(b2JointId jointId);
    void DistanceJoint_SetLengthRange(b2JointId jointId, float minLength, float maxLength);
    boolean DistanceJoint_IsLimitEnabled(b2JointId jointId);
    void DistanceJoint_EnableLimit(b2JointId jointId, boolean enableLimit);
    float DistanceJoint_GetCurrentLength(b2JointId jointId);
    boolean DistanceJoint_IsMotorEnabled(b2JointId jointId);
    void DistanceJoint_EnableMotor(b2JointId jointId, boolean enableMotor);
    void DistanceJoint_SetMotorSpeed(b2JointId jointId, float motorSpeed);
    float DistanceJoint_GetMotorSpeed(b2JointId jointId);
    void DistanceJoint_SetMaxMotorForce(b2JointId jointId, float force);
    float DistanceJoint_GetMaxMotorForce(b2JointId jointId);
    float DistanceJoint_GetMotorForce(b2JointId jointId);
    float DistanceJoint_GetLength(b2JointId jointId);
    void DistanceJoint_SetLength(b2JointId jointId, float length);

    // --- Revolute Joint ---
    float RevoluteJoint_GetAngle(b2JointId jointId);
    boolean RevoluteJoint_IsSpringEnabled(b2JointId jointId);
    void RevoluteJoint_EnableSpring(b2JointId jointId, boolean enableSpring);
    void RevoluteJoint_SetSpringHertz(b2JointId jointId, float hertz);
    float RevoluteJoint_GetSpringHertz(b2JointId jointId);
    void RevoluteJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);
    float RevoluteJoint_GetSpringDampingRatio(b2JointId jointId);
    boolean RevoluteJoint_IsLimitEnabled(b2JointId jointId);
    void RevoluteJoint_EnableLimit(b2JointId jointId, boolean enableLimit);
    float RevoluteJoint_GetLowerLimit(b2JointId jointId);
    float RevoluteJoint_GetUpperLimit(b2JointId jointId);
    void RevoluteJoint_SetLimits(b2JointId jointId, float lower, float upper);
    boolean RevoluteJoint_IsMotorEnabled(b2JointId jointId);
    void RevoluteJoint_EnableMotor(b2JointId jointId, boolean enableMotor);
    void RevoluteJoint_SetMotorSpeed(b2JointId jointId, float motorSpeed);
    float RevoluteJoint_GetMotorSpeed(b2JointId jointId);
    void RevoluteJoint_SetMaxMotorTorque(b2JointId jointId, float torque);
    float RevoluteJoint_GetMaxMotorTorque(b2JointId jointId);
    float RevoluteJoint_GetMotorTorque(b2JointId jointId);
    void RevoluteJoint_SetTargetAngle(b2JointId jointId, float angle);
    float RevoluteJoint_GetTargetAngle(b2JointId jointId);

    // --- Prismatic Joint ---
    float PrismaticJoint_GetTranslation(b2JointId jointId);
    float PrismaticJoint_GetSpeed(b2JointId jointId);
    boolean PrismaticJoint_IsSpringEnabled(b2JointId jointId);
    void PrismaticJoint_EnableSpring(b2JointId jointId, boolean enableSpring);
    void PrismaticJoint_SetSpringHertz(b2JointId jointId, float hertz);
    float PrismaticJoint_GetSpringHertz(b2JointId jointId);
    void PrismaticJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);
    float PrismaticJoint_GetSpringDampingRatio(b2JointId jointId);
    boolean PrismaticJoint_IsLimitEnabled(b2JointId jointId);
    void PrismaticJoint_EnableLimit(b2JointId jointId, boolean enableLimit);
    float PrismaticJoint_GetLowerLimit(b2JointId jointId);
    float PrismaticJoint_GetUpperLimit(b2JointId jointId);
    void PrismaticJoint_SetLimits(b2JointId jointId, float lower, float upper);
    boolean PrismaticJoint_IsMotorEnabled(b2JointId jointId);
    void PrismaticJoint_EnableMotor(b2JointId jointId, boolean enableMotor);
    void PrismaticJoint_SetMotorSpeed(b2JointId jointId, float motorSpeed);
    float PrismaticJoint_GetMotorSpeed(b2JointId jointId);
    void PrismaticJoint_SetMaxMotorForce(b2JointId jointId, float force);
    float PrismaticJoint_GetMaxMotorForce(b2JointId jointId);
    float PrismaticJoint_GetMotorForce(b2JointId jointId);
    void PrismaticJoint_SetTargetTranslation(b2JointId jointId, float translation);
    float PrismaticJoint_GetTargetTranslation(b2JointId jointId);

    // --- Wheel Joint ---
    boolean WheelJoint_IsSpringEnabled(b2JointId jointId);
    void WheelJoint_EnableSpring(b2JointId jointId, boolean enableSpring);
    void WheelJoint_SetSpringHertz(b2JointId jointId, float hertz);
    float WheelJoint_GetSpringHertz(b2JointId jointId);
    void WheelJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);
    float WheelJoint_GetSpringDampingRatio(b2JointId jointId);
    boolean WheelJoint_IsLimitEnabled(b2JointId jointId);
    void WheelJoint_EnableLimit(b2JointId jointId, boolean enableLimit);
    float WheelJoint_GetLowerLimit(b2JointId jointId);
    float WheelJoint_GetUpperLimit(b2JointId jointId);
    void WheelJoint_SetLimits(b2JointId jointId, float lower, float upper);
    boolean WheelJoint_IsMotorEnabled(b2JointId jointId);
    void WheelJoint_EnableMotor(b2JointId jointId, boolean enableMotor);
    void WheelJoint_SetMotorSpeed(b2JointId jointId, float motorSpeed);
    float WheelJoint_GetMotorSpeed(b2JointId jointId);
    void WheelJoint_SetMaxMotorTorque(b2JointId jointId, float torque);
    float WheelJoint_GetMaxMotorTorque(b2JointId jointId);
    float WheelJoint_GetMotorTorque(b2JointId jointId);

    // --- Weld Joint ---
    void WeldJoint_SetLinearHertz(b2JointId jointId, float hertz);
    float WeldJoint_GetLinearHertz(b2JointId jointId);
    void WeldJoint_SetLinearDampingRatio(b2JointId jointId, float dampingRatio);
    float WeldJoint_GetLinearDampingRatio(b2JointId jointId);
    void WeldJoint_SetAngularHertz(b2JointId jointId, float hertz);
    float WeldJoint_GetAngularHertz(b2JointId jointId);
    void WeldJoint_SetAngularDampingRatio(b2JointId jointId, float dampingRatio);
    float WeldJoint_GetAngularDampingRatio(b2JointId jointId);

    // --- Motor Joint ---
    b2Vec2 MotorJoint_GetLinearOffset(b2JointId jointId);
    void MotorJoint_SetLinearOffset(b2JointId jointId, b2Vec2 linearOffset);
    float MotorJoint_GetAngularOffset(b2JointId jointId);
    void MotorJoint_SetAngularOffset(b2JointId jointId, float angularOffset);
    float MotorJoint_GetMaxForce(b2JointId jointId);
    void MotorJoint_SetMaxForce(b2JointId jointId, float maxForce);
    float MotorJoint_GetMaxTorque(b2JointId jointId);
    void MotorJoint_SetMaxTorque(b2JointId jointId, float maxTorque);
    float MotorJoint_GetCorrectionFactor(b2JointId jointId);
    void MotorJoint_SetCorrectionFactor(b2JointId jointId, float correctionFactor);

    // --- Mouse Joint ---
    b2Vec2 MouseJoint_GetTarget(b2JointId jointId);
    void MouseJoint_SetTarget(b2JointId jointId, b2Vec2 target);
    float MouseJoint_GetMaxForce(b2JointId jointId);
    void MouseJoint_SetMaxForce(b2JointId jointId, float maxForce);
    float MouseJoint_GetSpringHertz(b2JointId jointId);
    void MouseJoint_SetSpringHertz(b2JointId jointId, float hertz);
    float MouseJoint_GetSpringDampingRatio(b2JointId jointId);
    void MouseJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);

    // --- Geometry creation ---
    b2Polygon MakeSquare(float halfWidth);
    b2Polygon MakeBox(float halfWidth, float halfHeight);
    b2Polygon MakeRoundedBox(float halfWidth, float halfHeight, float radius);
    b2Polygon MakeOffsetBox(float halfWidth, float halfHeight, b2Vec2 center, b2Rot rotation);
    b2Polygon MakeOffsetRoundedBox(float halfWidth, float halfHeight, b2Vec2 center, b2Rot rotation, float radius);
    b2Polygon MakePolygon(b2Hull hull, float radius);
    b2Polygon MakeOffsetPolygon(b2Hull hull, b2Vec2 position, b2Rot rotation);
    b2Polygon MakeOffsetRoundedPolygon(b2Hull hull, b2Vec2 position, b2Rot rotation, float radius);
    b2Polygon TransformPolygon(b2Transform transform, b2Polygon polygon);
    b2Rot MakeRot(float angle);

    // --- Geometry testing ---
    boolean PointInCircle(b2Vec2 point, b2Circle shape);
    boolean PointInCapsule(b2Vec2 point, b2Capsule shape);
    boolean PointInPolygon(b2Vec2 point, b2Polygon shape);
    boolean ValidateHull(b2Hull hull);

    // --- Geometry computation ---
    b2Hull ComputeHull(b2Vec2 points, long count);
    b2MassData ComputeCircleMass(b2Circle shape, float density);
    b2MassData ComputeCapsuleMass(b2Capsule shape, float density);
    b2MassData ComputePolygonMass(b2Polygon shape, float density);
    b2AABB ComputeCircleAABB(b2Circle shape, b2Transform transform);
    b2AABB ComputeCapsuleAABB(b2Capsule shape, b2Transform transform);
    b2AABB ComputePolygonAABB(b2Polygon shape, b2Transform transform);
    b2AABB ComputeSegmentAABB(b2Segment shape, b2Transform transform);

    // --- AABB utilities ---
    b2Vec2 AABB_Center(b2AABB aabb);
    b2Vec2 AABB_Extents(b2AABB aabb);
    boolean AABB_Contains(b2AABB a, b2AABB b);
    boolean AABB_Overlaps(b2AABB a, b2AABB b);
    b2AABB AABB_Union(b2AABB a, b2AABB b);

    // --- Make utilities ---
    b2AABB MakeAABB(b2Vec2 points, long count, float radius);
    b2ShapeProxy MakeProxy(b2Vec2 points, long count, float radius);
    b2ShapeProxy MakeOffsetProxy(b2Vec2 points, long count, float radius, b2Vec2 position, b2Rot rotation);

    // --- Collide functions (return b2Manifold → void, manifold data accessed via extra functions) ---
    void CollideCircles(b2Circle circleA, b2Transform xfA, b2Circle circleB, b2Transform xfB);
    void CollideCapsuleAndCircle(b2Capsule capsuleA, b2Transform xfA, b2Circle circleB, b2Transform xfB);
    void CollideSegmentAndCircle(b2Segment segmentA, b2Transform xfA, b2Circle circleB, b2Transform xfB);
    void CollidePolygonAndCircle(b2Polygon polygonA, b2Transform xfA, b2Circle circleB, b2Transform xfB);
    void CollideCapsules(b2Capsule capsuleA, b2Transform xfA, b2Capsule capsuleB, b2Transform xfB);
    void CollideSegmentAndCapsule(b2Segment segmentA, b2Transform xfA, b2Capsule capsuleB, b2Transform xfB);
    void CollidePolygonAndCapsule(b2Polygon polygonA, b2Transform xfA, b2Capsule capsuleB, b2Transform xfB);
    void CollidePolygons(b2Polygon polygonA, b2Transform xfA, b2Polygon polygonB, b2Transform xfB);
    void CollideSegmentAndPolygon(b2Segment segmentA, b2Transform xfA, b2Polygon polygonB, b2Transform xfB);
    void CollideChainSegmentAndCircle(b2ChainSegment segmentA, b2Transform xfA, b2Circle circleB, b2Transform xfB);

    // --- Ray cast / shape cast on shapes ---
    b2CastOutput RayCastCircle(b2RayCastInput input, b2Circle shape);
    b2CastOutput RayCastCapsule(b2RayCastInput input, b2Capsule shape);
    b2CastOutput RayCastSegment(b2RayCastInput input, b2Segment shape, boolean oneSided);
    b2CastOutput RayCastPolygon(b2RayCastInput input, b2Polygon shape);
    b2CastOutput ShapeCastCircle(b2ShapeCastInput input, b2Circle shape);
    b2CastOutput ShapeCastCapsule(b2ShapeCastInput input, b2Capsule shape);
    b2CastOutput ShapeCastSegment(b2ShapeCastInput input, b2Segment shape);
    b2CastOutput ShapeCastPolygon(b2ShapeCastInput input, b2Polygon shape);

    // --- Time of impact ---
    b2TOIOutput TimeOfImpact(b2TOIInput input);

    // --- Rotation ---
    float Rot_GetAngle(b2Rot q);
    b2Vec2 Rot_GetXAxis(b2Rot q);
    b2Vec2 Rot_GetYAxis(b2Rot q);
    b2Rot ComputeRotationBetweenUnitVectors(b2Vec2 v1, b2Vec2 v2);
    float ComputeAngularVelocity(b2Rot q1, b2Rot q2, float inv_h);

    // --- Math utilities ---
    float Atan2(float y, float x);
    b2CosSin ComputeCosSin(float radians);
    void SetLengthUnitsPerMeter(float lengthUnits);
    float GetLengthUnitsPerMeter();

    // --- Version / timing ---
    b2Version GetVersion();
    long GetTicks();
    float GetMilliseconds(boolean reset);
    long GetByteCount();

    // --- ArrayAdapter operations ---
    [ArrayAdapter, CountFunc="b2Body_GetShapeCount"]
    b2ShapeId Body_GetShapes(b2BodyId bodyId);

    [ArrayAdapter, CountFunc="b2Body_GetJointCount"]
    b2JointId Body_GetJoints(b2BodyId bodyId);

    [ArrayAdapter, CountFunc="b2Shape_GetSensorCapacity"]
    b2ShapeId Shape_GetSensorOverlaps(b2ShapeId shapeId);

    [ArrayAdapter, CountFunc="b2Chain_GetSegmentCount"]
    b2ShapeId Chain_GetSegments(b2ChainId chainId);
};

// ===== Event Adapters =====

[CFunc="b2World_GetContactEvents"]
event world_get_contact_events(b2WorldId worldId) : b2ContactEvents {
    begin_events(beginEvents, beginCount) {
        b2ShapeId shape_id_a = shapeIdA;
        b2ShapeId shape_id_b = shapeIdB;
    };
    end_events(endEvents, endCount) {
        b2ShapeId shape_id_a = shapeIdA;
        b2ShapeId shape_id_b = shapeIdB;
    };
    hit_events(hitEvents, hitCount) {
        b2ShapeId shape_id_a = shapeIdA;
        b2ShapeId shape_id_b = shapeIdB;
        b2Vec2 point = point;
        b2Vec2 normal = normal;
        float approach_speed = approachSpeed;
    };
};

[CFunc="b2World_GetSensorEvents"]
event world_get_sensor_events(b2WorldId worldId) : b2SensorEvents {
    begin_events(beginEvents, beginCount) {
        b2ShapeId sensor_shape_id = sensorShapeId;
        b2ShapeId visitor_shape_id = visitorShapeId;
    };
    end_events(endEvents, endCount) {
        b2ShapeId sensor_shape_id = sensorShapeId;
        b2ShapeId visitor_shape_id = visitorShapeId;
    };
};

[CFunc="b2World_GetBodyEvents"]
event world_get_body_events(b2WorldId worldId) : b2BodyEvents {
    move_events(moveEvents, moveCount) {
        b2Transform transform = transform;
        b2BodyId body_id = bodyId;
        boolean fell_asleep = fellAsleep;
    };
};
